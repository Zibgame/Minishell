âœ… 1. Fix immÃ©diats (bugs Ã  corriger maintenant)
a) Memory leaks

Tu nâ€™as jamais free les cmd.args crÃ©Ã©s dans create_command.
Tu dois free args + la struct command aprÃ¨s chaque utilisation.

ğŸ‘‰ Dans shell_loop, aprÃ¨s :

cmd = create_command(line);


il faut ajouter :

free_array(cmd.args);


Sinon tu vas avoir une fuite Ã  chaque commande.

b) exec_cmd : leaks + comportement incohÃ©rent

Tu fais :

args = ft_split(line, ' ');
...
return ;


â†’ si la commande nâ€™existe pas tu return sans free.

â†’ leak massif
â†’ pas de message pour les builtins sans arguments

ğŸ’¡ Astuce : utilise cmd.args (dÃ©jÃ  split), pas ft_split(line, ' ') une deuxiÃ¨me fois.

c) signaux incorrects

Ton handler pour SIGINT fait :

write(1, "\nminishell> ", 12);


â†’ readline BYPASSE ce comportement
â†’ le prompt devient cassÃ© (^Cminishell>)

Il faut utiliser rl_replace_line, rl_on_new_line, rl_redisplay.

Je te donne la version propre juste aprÃ¨s â¬‡ï¸

âœ… 2. Ce que tu dois coder maintenant

Voici lâ€™ordre logique pour la suite de minishell.

ğŸ”¥ Ã‰tape 1 : Fixer les signaux correctement

Mets Ã§a dans sig_handler.c (respecte la norme) :

#include "../../includes/minishell.h"

void    sigint_handler(int sig)
{
    if (sig == SIGINT)
    {
        write(1, "\n", 1);
        rl_on_new_line();
        rl_replace_line("", 0);
        rl_redisplay();
    }
}


Et dans init_signal() :

signal(SIGINT, sigint_handler);
signal(SIGQUIT, SIG_IGN);


ğŸ’¬ Explication :
Ã‡a remet proprement la ligne de readline aprÃ¨s un CTRL+C.

ğŸ”¥ Ã‰tape 2 : Refactor exec_cmd pour utiliser t_cmd

Il faut arrÃªter de faire 2 splits.
Voici une version propre :

void    exec_cmd(t_shell *shell, t_cmd *cmd)
{
    pid_t   pid;
    char    *path;

    path = get_cmd_path(shell, cmd->name);
    if (!path)
    {
        printf("minishell: %s: command not found\n", cmd->name);
        return ;
    }
    pid = fork();
    if (pid == 0)
    {
        execve(path, cmd->args, shell->envp_tmp);
        perror("execve");
        exit(127);
    }
    waitpid(pid, NULL, 0);
    free(path);
}

ğŸ”¥ Ã‰tape 3 : Mettre en place un parser minimal

Ton minishell ne gÃ¨re pas :

quotes ""

quotes '

redirections < > << >>

pipelines |

expansion $VAR

Câ€™est la prochaine Ã©tape.

ğŸ‘‰ Commence simple : gÃ©rer les quotes
CrÃ©e une fonction split_with_quotes() qui dÃ©coupe correctement.

Tu pourras ensuite ajouter :

lexer â†’ parser â†’ executor

ğŸ”¥ Ã‰tape 4 : Builtins manquants

Tu nâ€™as pas encore codÃ© :

echo (avec -n)

cd

export

unset

Avant dâ€™aller plus loin, Ã©cris echo -n, câ€™est rapide.

ğŸ¯ Plan de travail 42-friendly

Voici le plan exact que les binÃ´mes suivent :

âœ”ï¸ env list, get_value, PATH

âœ”ï¸ execve + fork

âœ”ï¸ builtins basics (env, pwd, exit)

ğŸ§© refactor exec_cmd + signal + free

ğŸ”¥ echo / cd / export / unset

ğŸŒªï¸ lexer avec quotes

ğŸ§± parser

ğŸ”— pipes / redirections

â™»ï¸ heredoc avec signaux
